# Thinking-with-Reference-Frames
Many of the projects I've worked on have used IMUs in either very advanced (flight control) or rather specific (concussion detection) manners.  If there's one thing I've learned from these projects, its the importance of understanding reference frames.  A reference frame is a slightly-mathy term, so google it with caution.  I do not have a strong math background and was not exposed to reference frames until working in industry.  And I can tell you its an illuminating concept.
A reference frame is the viewpoint of some specific domain of your system.  Think of it as the 3D origin of the 'thing'.  Let's take a very simple example of a hockey puck with a 6 axis IMU attached on its side.  Here, we can easily describe two reference frames - the world's and the puck's.  The world is the reference frame that we think in and usually where we want to measure data in relation to.  That is to say, when we talk about 'orientation' its usually in the world frame (respect to gravity and magnetic north - such as 'our rocket is crashing down to the ground and moving to our east').  Now its obvious that the IMU has its own...orientation for lack of a better term... because its mounted on this moving puck in some arbitrary manner.  What we normally do with IMU data is we find a way of rotating the IMU data into the world reference frame.  Think about the XYZ coordinates of the imu mounted on the side of the puck.  The raw Z axis will point horizontally off the puck's side (when you see or think 'raw' in these cases, you usually are thinking of the IMU's local or native reference frame).  Commonly, we would use gravity (a fixed reference point in the world frame) to establish the rotation that would put the IMU's Z axis pointing 'down' as we expect.  If you aren't familiar with with technique it goes a little like so: we use a fairly strong low pass filter (a filter that effectively slows down or resists changes in signal data only giving us the constant data and removing any jitter) on the raw IMU accelerometer data to find the vector (everything can and should be thought of as a vector here) that doesn't change over time.  That vector we can usually assume to be the gravity component because the gravity vector will be a constant magnitude and reasonably constant direction compared to other stuff going on with the IMU (assuming the IMU is relatively stationary such as at rest or perhaps even held steady in your hand - it falls apart if you try to do this calibration while launching a rocket).  That new found gravity vector will not be pointing perfectly in any one IMU axis.  We may find that it points about half on the X and half on the -Y axes or some other arbitrary combination.  This is where we use the very clever techniques taught to us by really smart people to find a rotation that moves that arbitrary gravity vector such that it is pointing down -Z (for the crash course therein, I know of no better resource than NXP's "Tilt Sensing Using a Three Axis Accelerometer" https://www.nxp.com/docs/en/application-note/AN3461.pdf).  Whatever rotation we found that moved {1/2X, -1/2Y} into -1Z is the transformation from the IMU reference frame into the world reference frame (well, only for the X and Y axes, the Z axis is still arbitrary).  That transformation will move data out of one reference frame and into another.  That's a very powerful concept.

It seems we never are so lucky as to only have two reference frames to deal with, as in this example.  At minimum we also have the reference frame of the object we are mounted to.  In the previous example, the hockey puck doesn't really have an independent reference frame because it doesn't have a front.  But what if it was a car?  Now we really care about the relationship between the IMU and the car's front.  The IMU is going to be mounted at some arbitrary angle again, and this time we need to know where the front of the car is pointing according to the IMU.  If that doesn't quite make sense, think about when the car moves forward, the IMU will register some raw data about its acceleration but it may not be perfectly in one axis.  Perhaps the IMU is mounted on the curve of the rear bumper where its Z and X axes will be pointing partially towards the front.  What we've done here is introduce another reference frame - the car's.  And what needs to be done is to find a rotation that moves the IMU into the car's reference frame.  How that is done, is up to debate (is it reasonable to assume we could look for the first straight-line acceleration? Perhaps).  But the point is, to think of theses things as reference frames.  So let's assume we find a clever technique to figure out the front of the car similar to how we figured out where gravity was pointing.  Then you create a rotation that takes the IMU into the car reference frame.  Imagine this as literally taking the IMU X axis and rotating it so its aligned them with the car's X.  And we have a very nice advantage of knowing that this rotation will not change.  That is to say that we know the IMU can't rotate once its mounted to the car.  What does that get us?  Well, that means we can just always apply that rotation to our raw data right away.  So, we rotate the IMU into the car frame before we find gravity, then use that to rotate again into the world frame to find out our car is parked on an incline (headding is still arbitrary because we have no fixed reference point in the world frame without a compas to estimate magnetic north).  It all works out quite well.
An example of a system with even more obvious reference frames (sometimes they aren't obvious) is an robotic arm.  Or what about a wearable device on a person's arm where we want to track the user's gestures?  That gets complicated.
It can be overwhelming to try think of these more complex systems without breaking it down into reference frames such as this.  Infact, its the right way to do it, and if you look at some advanced source code you can find dozens of reference frames for even fairly simple systems.  I wouldn't be surprised to find a half dozen in a quadrocopter flight controll.  I will try to explain better in the future and provide more examples!

# Thinking with Reference Frames
Many of the projects I've worked on have used IMUs in either very advanced (flight control) or rather specific (concussion detection) manners.  If there's one thing I've learned from these projects, its the importance of understanding reference frames and thinking of IMU problems in terms of reference frames.

## What does Reference Frame Mean?
![alt text](https://github.com/jacrabb/Thinking-with-Reference-Frames/raw/master/ReferenceFrameDiscussion/frames.png "Ref Frames")
A reference frame is the viewpoint of some specific domain of your system.  Think of it as the 3D origin of a 'thing'.  When you have an IMU mounted on, for instance, an aircraft - that IMU has an 'up', the aircraft has an 'up', the world has an 'up'.  These are your reference frames - IMU, aircraft, world.

## What do You do with a [drunken] Reference Frame?
Often times the first thing you do with an IMU is find some rotation that brings it into the world frame.  That is to say that the Z axis is pointing up/down as expected and the accelarometer reads Z = -1g.  This is pretty universal because gravity is a great fixed refernce point in the world frame that we can rely on.  What this rotation (could be a matrix or a roll/pitch/yaw or a quaternion) does is move from one reference frame to another, specifically from the IMU's local frame into the world frame.  Makes sense.  Now you can describe rotations in a way that makes intuative sense such as incline/decline or turning left/right.
The piece that is often overlooked is that we have skipped or ignored the aircraft's reference frame.  That's because we assume the IMU and the aircraft are sort of one unit.  We mounted the IMU with the Z axis pointing down and so that should do it.  But things get tricky when you want to measure something on the aircraft that's not fixed.  Lets say we have a camera mounted on the bottom of the aircraft and only an IMU on the camera to tell us where its pointing.  Its tempting to say we can ignore the aircraft frame here as well because you can think of the camera only in the world frame as well.  But that doesn't capture the while story.  At minimum we want to know if the camera is looking 'forward' in the aircraft frame.  We also may want to know the pitch of the camera so that we don't point too far up and perhaps bump the camera into the prop or something.  This is where we start to think in reference frames.  We want to know that the aircraft is level and pointing north in the world frame and we want to know that the camera is level and pointing forward relative to the aircraft.  As the aircraft pitches up, we still expect to know that the camera is looking directly where the aircraft is going while at the same time knowing how to make the camera level to the ground if we want.  So there you have a situation where you want to keep track of orientation in two reference frames.

## So What do You do About It?
Its important to understand the refernce frames in your system conceptually and perhaps even draw them on paper.  Keep track of exactly how you are moving between reference frames in your code.  In the case of our aircraft and camera, you'll find that you can look at both orientations in the world frame and subtract the camera orientation from the aircraft orientation to figure out how the camera is pointing relative to the aircraft.  Using euler angles that works out to just be subtraction of roll, pitch, and yaw.  If you are using quaternions there is an elegant solution of multiplying the camera orientation by the conjugate (or 'inverse') of the aircraft orientation.  I say it like its easy...
Again, its important to keep track of what reference frame you are in and what frame you are moving to.  The straight forward thing to do is to move everything into the world frame and then figure out thier relationship from there.  In the camera example, we moved the aircraft and camera into the world frame and then to find what angle the camera was to the plane, we can subtract the camera.roll from aircraft.roll.  With quaternions we would do something like camera.Q * aircraft.Q.conj().  
But life is not always so simple and sometimes we need more complex movements between refernce frames.  Sometimes we have to derive reference frames on the fly - perhaps based on a user's gesture.  Imagine a situation where you don't know exactly how an IMU is mounted.  A wearable sensor comes to mind as an example.
What if there are two sensors, one on the chest, the other on the wrist!  You can drive yourself nuts sorting out these more complex scarios without considering the movement from reference frame to reference frame.
I'm not going to advocate any particular way of implementing these concepts, but I will say that when you find yourself with a quaternion orientation things tend to work out quite elegantly.


# Hocky Puck Example
Let's take a very simple example of a hockey puck with a 6 axis IMU attached on its side.  Here, we can easily describe two reference frames - the world's and the puck's.  The world is the reference frame that we think in and usually where we want to measure data in relation to.  That is to say, when we talk about 'orientation' its usually in the world frame (respect to gravity and magnetic north - such as 'our rocket is crashing down to the ground and moving to the east').  Now its obvious that the IMU has its own...orientation for lack of a better term... because its mounted on this moving puck in some arbitrary manner.  What we normally do with IMU data is we find a way of rotating the IMU data into the world reference frame.  Think about the XYZ coordinates of the imu mounted on the side of the puck.  The raw Z axis will point horizontally off the puck's side (when you see or think 'raw' in these cases, you usually are thinking of the IMU's local or native reference frame).  Commonly, we would use gravity (a fixed reference point in the world frame) to establish the rotation that would put the IMU's Z axis pointing 'down' as we expect.  If you aren't familiar with with technique it goes a little like so: we use a fairly strong low pass filter (a filter that effectively slows down or resists changes in signal data only giving us the constant data and removing any jitter) on the raw IMU accelerometer data to find the vector (everything can and should be thought of as a vector here) that doesn't change over time.  That vector we can usually assume to be the gravity component because the gravity vector will be a constant magnitude and reasonably constant direction compared to other stuff going on with the IMU (assuming the IMU is relatively stationary such as at rest or perhaps even held steady in your hand - it falls apart if you try to do this calibration while launching a rocket).  That new found gravity vector will not be pointing perfectly in any one IMU axis.  We may find that it points about half on the X and half on the -Y axes or some other arbitrary combination.  This is where we use the very clever techniques taught to us by really smart people to find a rotation that moves that arbitrary gravity vector such that it is pointing down -Z (for the crash course therein, I know of no better resource than NXP's "Tilt Sensing Using a Three Axis Accelerometer" https://www.nxp.com/docs/en/application-note/AN3461.pdf).  Whatever rotation we found that moved {1/2X, -1/2Y} into -1Z is the transformation from the IMU reference frame into the world reference frame (well, only for the X and Y axes, the Z axis is still arbitrary).  That transformation will move data out of one reference frame and into another.  That's a very powerful concept.

It seems we never are so lucky as to only have two reference frames to deal with, as in this example.  At minimum we also have the reference frame of the object we are mounted to.  In the previous example, the hockey puck doesn't really have an independent reference frame because it doesn't have a front.  But what if it was a car?  Now we really care about the relationship between the IMU and the car's front.  The IMU is going to be mounted at some arbitrary angle again, and this time we need to know where the front of the car is pointing according to the IMU.  If that doesn't quite make sense, think about when the car moves forward, the IMU will register some raw data about its acceleration but it may not be perfectly in one axis.  Perhaps the IMU is mounted on the curve of the rear bumper where its Z and X axes will be pointing partially towards the front.  What we've done here is introduce another reference frame - the car's.  And what needs to be done is to find a rotation that moves the IMU into the car's reference frame.  How that is done, is up to debate (is it reasonable to assume we could look for the first straight-line acceleration? Perhaps).  But the point is, to think of theses things as reference frames.  So let's assume we find a clever technique to figure out the front of the car similar to how we figured out where gravity was pointing.  Then you create a rotation that takes the IMU into the car reference frame.  Imagine this as literally taking the IMU X axis and rotating it so its aligned them with the car's X.  And we have a very nice advantage of knowing that this rotation will not change.  That is to say that we know the IMU can't rotate once its mounted to the car.  What does that get us?  Well, that means we can just always apply that rotation to our raw data right away.  So, we rotate the IMU into the car frame before we find gravity, then use that to rotate again into the world frame to find out our car is parked on an incline (headding is still arbitrary because we have no fixed reference point in the world frame without a compas to estimate magnetic north).  It all works out quite well.
An example of a system with even more obvious reference frames (sometimes they aren't obvious) is an robotic arm.  Or what about a wearable device on a person's arm where we want to track the user's gestures?  That gets complicated.
It can be overwhelming to try think of these more complex systems without breaking it down into reference frames such as this.  Infact, its the right way to do it, and if you look at some advanced source code you can find dozens of reference frames for even fairly simple systems.  I wouldn't be surprised to find a half dozen in a quadrocopter flight controll.  I will try to explain better in the future and provide more examples!
